# Моноиды и Полугруппы {#sec:monoids}

В этой главе мы изучим наши первые тайпклассы - **моноид** и **полугруппу**.
Они позволяют складывать и сочетать значения.
Их экземпляры существуют для типов `Int`, `String`, `List`, `Option` и многих других.
Давайте начнем с рассмотрения нескольких простых типов и операций
чтобы увидеть, какие общие принципы можно извлечь.

**Сложение целых чисел**

Сложение целых чисел (`Int`) является *замкнутой* бинарной операцией,
потому что её применение над двумя `Int` всегда возвращает другой `Int`:

```tut:book
2 + 1
```

Кроме того, существует *тождественный* (identity) элемент `0` такой, что
 `a + 0 == 0 + a == a` для любого `Int` `a`:

```tut:book
2 + 0

0 + 2
```

У сложения есть и другие свойства.
Например, вне зависимости от порядка, в котором мы складываем элементы,
мы всегда получим тот же самый результат.
Это свойство называется *ассоциативность*:

```tut:book
(1 + 2) + 3

1 + (2 + 3)
```

**Умножение целых чисел**

Эти же свойства сложения применимы и для умножения,
если в качестве тождественного элемента мы используем `1` вместо `0`:

```tut:book
1 * 3

3 * 1
```

Умножение, как и сложение, ассоциативно:

```tut:book
(1 * 2) * 3

1 * (2 * 3)
```

**Конкатенация строк и последовательностей**

Мы так же можем складывать и строки (`String`),
используя в качестве бинарной операции конкатенацию: 

```tut:book
"One" ++ "two"
```

а пустую строку как тождественный элемент:

```tut:book
"" ++ "Hello"

"Hello" ++ ""
```

И снова, конкатенация является ассоциативной:

```tut:book
("One" ++ "Two") ++ "Three"

"One" ++ ("Two" ++ "Three")
```

Обратите внимание, что выше мы использовали `++` вместо более привычного `+`
чтобы провести параллель с последовательностями.
Используя конкатенацию как бинарную операцию,
а пустую последовательность для тождественности,
мы можем делать то же самое с последовательностями любых других типов.

## Определение Моноида

Выше мы рассмотрели несколько вариантов "сложения", 
каждый с ассоциативной бинарной операцией
и тождественным элементом.
Нет ничего удивительного в том, что это и есть моноид.
Формально, моноид для типа `A` это:

- операция сочетания (`combine`) с типом `(A, A) => A`
- пустой (`empty`) элемент типа `A`

Это определение хорошо ложится на Scala-код.
Так выглядит упрощенная версия определения от Cats:

```tut:book:silent
trait Monoid[A] {
  def combine(x: A, y: A): A
  def empty: A
}
```

Помимо предоставления `combine` и `empty`,
моноиды должны подчиняться нескольким формальным *законам*.
Для любых `x`, `y`, и `z`, из `A`,
операция `combine` должна быть ассоциативной, а
элемент `empty` должен быть тождественным элементом:

```tut:book:silent
def associativeLaw[A](x: A, y: A, z: A)
      (implicit m: Monoid[A]): Boolean = {
  m.combine(x, m.combine(y, z)) ==
    m.combine(m.combine(x, y), z)
}

def identityLaw[A](x: A)
      (implicit m: Monoid[A]): Boolean = {
  (m.combine(x, m.empty) == x) &&
    (m.combine(m.empty, x) == x)
}
```

Например, разница целых чисел не является моноидом,
так как вычитание не ассоциативно:

```tut:book
(1 - 2) - 3

1 - (2 - 3)
```

На практике о законах приходится думать только 
когда мы пишем собственные экземпляры `Monoid`.
Экземпляры, для которых не выполняются законы - опасны, 
так как могут привести к непредсказуемым результатам
при использовании с остальной струкрутрой Cats.
Полагая, что авторы библиотеки знают, что они делают,
в большинстве случаев можно полагаться на экземпляры предоставляемые Cats.

## Определение полугруппы

Полугруппа это всего лишь `combine` часть моноида.
И хотя полугруппы зачастую являются моноидами,
для некоторых типов данных нельзя определить элемент `empty`.
Например, как мы только что видели, моноидами являются
конкатенация последовательностей и сложение целых чисел.
Однако, если мы ограничимся непустыми последовательностями и положительными числами,
мы больше не сможем определить осмысленный элемент `empty`.
В Cats есть тип данных [`NonEmptyList`][cats.data.NonEmptyList] 
для которого есть реализация `Semigroup` но отсутсвует `Monoid`.

Более точное (но по-прежнему упращенное)
определение [`Monoid`][cats.Monoid] в Cats:

```tut:book:silent
trait Semigroup[A] {
  def combine(x: A, y: A): A
}

trait Monoid[A] extends Semigroup[A] {
  def empty: A
}
```

При изучении тайпклассов, такой вид наследования мы будем видеть часто.
Он обеспечивает модульность и позволяет переиспользовать поведение.
Если мы определим `Monoid` для типа `A`, мы автоматически получим `Semigroup`.
Аналогично, если методу нужен параметр с типом `Semigroup[B]`,
мы можем вместо этого передать `Monoid[B]`.

## Упражнение: Истинные Моноиды

Мы посмотрели на несколько примеров моноида, но найти их можно гораздо больше. 
Рассмотрим `Boolean`. Сколько моноидов вы сможете определить для этого типа?
Для каждого моноида задайте операции `combine` и `empty`, а так же убедитесь,
что законы моноида соблюдены.
Для начала упражнения используйте определения ниже:

```tut:book:reset:silent
trait Semigroup[A] {
  def combine(x: A, y: A): A
}

trait Monoid[A] extends Semigroup[A] {
  def empty: A
}

object Monoid {
  def apply[A](implicit monoid: Monoid[A]) =
    monoid
}
```

<div class="solution">
Есть целых четыре моноида для типа `Boolean`!
Во-первых, у нас есть *и* с оператором `&&` и тождественным `true`:

```tut:book:silent
implicit val booleanAndMonoid: Monoid[Boolean] =
  new Monoid[Boolean] {
    def combine(a: Boolean, b: Boolean) = a && b
    def empty = true
  }
```

Во-вторых, есть *или* с оператором `||` и тождественным `false`:

```tut:book:silent
implicit val booleanOrMonoid: Monoid[Boolean] =
  new Monoid[Boolean] {
    def combine(a: Boolean, b: Boolean) = a || b
    def empty = false
  }
```

В-третьих, у нас есть *исключающее или* с тождественным `false`:

```tut:book:silent
implicit val booleanEitherMonoid: Monoid[Boolean] =
  new Monoid[Boolean] {
    def combine(a: Boolean, b: Boolean) =
      (a && !b) || (!a && b)

    def empty = false
  }
```

Наконец, у нас есть *ислючающее ни* (инверсия исключающего или)
с тождественным `true`:

```tut:book:silent
implicit val booleanXnorMonoid: Monoid[Boolean] =
  new Monoid[Boolean] {
    def combine(a: Boolean, b: Boolean) =
      (!a || b) && (a || !b)

    def empty = true
  }
```

Легко увидеть, что в каждом случае соблюдается закон тождественности.
Аналогично, простым перечислением значений может быть показана ассоциативность операции `combine`.
</div>

## Упражнение: Полное множество моноидов

Какие моноиды и полугруппы есть для множеств?

<div class="solution">
*Объединение можеств* наряду с пустым множеством образуют моноид:

```tut:book:silent
implicit def setUnionMonoid[A]: Monoid[Set[A]] =
  new Monoid[Set[A]] {
    def combine(a: Set[A], b: Set[A]) = a union b
    def empty = Set.empty[A]
  }
```

Чтобы принимать любой типовый параметр `A`, неоходимо
определить `setUnionMonoid` как метод, а не значение.
Параметр типа позволяет нам переиспользовать определение
чтобы требовать `Monoid` для `Set` любого типа данных:

```tut:book:silent
val intSetMonoid = Monoid[Set[Int]]
val strSetMonoid = Monoid[Set[String]]
```

```tut:book
intSetMonoid.combine(Set(1, 2), Set(2, 3))
strSetMonoid.combine(Set("A", "B"), Set("B", "C"))
```

Операция пересечения множеств образует полугруппу,
но не является моноидом, т.к. у неё нет тождественного элемента:

```tut:book:silent
implicit def setIntersectionSemigroup[A]: Semigroup[Set[A]] =
  new Semigroup[Set[A]] {
    def combine(a: Set[A], b: Set[A]) =
      a intersect b
  }
```

Операции дополнения и разности множеств не ассоциативные,
поэтому не могут быть рассмотрены ни для моноида, ни для полугруппы.
Однако, симметричная разность (объединение без пересечения) и пустое множество
так же формируют моноид:

```tut:book:silent
implicit def symDiffMonoid[A]: Monoid[Set[A]] =
  new Monoid[Set[A]] {
    def combine(a: Set[A], b: Set[A]): Set[A] =
      (a diff b) union (b diff a)
    def empty: Set[A] = Set.empty
  }
```
</div>
