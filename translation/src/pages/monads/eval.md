## Монада «Eval» {#sec:monads:eval}

[`cats.Eval`][cats.Eval] — это монада, которая позволяет
абстрагироваться над разными *моделями вычисления*.
Обычно выделяют две модели вычислений: *энергичная* и *ленивая*.
`Eval` описывает различия между тем
*мемоизирован* ли результат или нет.

### Энергичные, Ленивые, Мемоизированные, подумать только!

Что означают эти термины?

*Энергичные* вычисления происходят немедленно,
тогда как *ленивые* происходят непосредственно при вызове вычисления.
*Мемоизированные* вычисления запускаются один раз при первом вызове,
после которых результаты кэшируются.

Например, `val` в Scala энергичные и мемоизированные.
Можно увидеть это, используя вычисление с видимым побочным эффектом.
В следующем примере,
код для вычисления значения `x`
вызывается в месте определения,
а не при обращении к нему (энергичный).
Доступ к `x` вызывает сохраненное значение
без повторного вычисления (мемоизированный).

```tut:book
val x = {
  println("Computing X")
  math.random
}

x // первый вызов
x // второй вызов
```

В отличие от этого, `def` ленивые и не мемоизированные.
Код для вычисления `y`, представленный ниже,
не будет запущен пока не вызвать его (ленивый),
и будет повторно запущен при каждом вызове (не мемоизированный):

```tut:book
def y = {
  println("Computing Y")
  math.random
}

y // первый вызов
y // второй вызов
```

И последнее, но не менее важное,
`lazy val` ленивые и мемоизированные.
Код, для вычисления `z`, представленный ниже,
не будет запущен пока не вызвать его
впервые (ленивый).
Затем результат кэшируется
и переиспользуется при последующих вызовах (мемоизированный):

```tut:book
lazy val z = {
  println("Computing Z")
  math.random
}

z // первый вызов
z // второй вызов
```

### Модели вычисления Eval

У `Eval` есть три подтипа: `Now`, `Later`, и `Always`.
Их инициализируют с помощью трёх методов,
которые создают экземпляры этих трёх классов
и возвращают их как тип `Eval`:

```tut:book:silent
import cats.Eval
```

```tut:book
val now = Eval.now(math.random + 1000)
val later = Eval.later(math.random + 2000)
val always = Eval.always(math.random + 3000)
```

Мы можем извлечь результат `Eval`,
используя метод `value`:

```tut:book
now.value
later.value
always.value
```

Каждый тип `Eval` вычисляет результат,
используя одну из определенных выше моделей вычисления.
`Eval.now` вычисляет значение *прямо сейчас*.
Его семантика похожа на `val` — энергичный и мемоизированный:

```tut:book
val x = Eval.now {
  println("Computing X")
  math.random
}

x.value // первый вызов
x.value // второй вызов
```

`Eval.always` описывает ленивое вычисление,
схожим образом с `def`:

```tut:book
val y = Eval.always {
  println("Computing Y")
  math.random
}

y.value // первый вызов
y.value // второй вызов
```

Наконец, `Eval.later` описывает ленивое, мемоизированное вычисление,
схожим образом с `lazy val`:

```tut:book
val z = Eval.later {
  println("Computing Z")
  math.random
}

z.value // первый вызов
z.value // второй вызов
```

Эти три поведения вычислений подытожены ниже:

-----------------------------------------------------------------------
Scala              Cats                      Свойства
------------------ ------------------------- --------------------------
`val`              `Now`                     энергичное, мемоизированное

`lazy val`         `Later`                   ленивое, мемоизированное

`def`              `Always`                  ленивое, не мемоизированное
------------------ ------------------------- --------------------------

### Eval — это монада

Как у всех монад, методы `map` и `flatMap` у `Eval` добавляют вычисления в последовательность.
Однако, в этом случае, последовательность явно хранится как список функций.
Функции не будут выполняться, пока не вызвать
метод `value` у `Eval`, чтобы запросить результат вычислений:

```tut:book
val greeting = Eval.
  always { println("Step 1"); "Hello" }.
  map { str => println("Step 2"); s"$str world" }

greeting.value
```

Обратите внимание, что в то время как семантика
исходных экземпляров `Eval` сохраняется,
отображение функций всегда
вызывается линиво и по требованию (семантика `def`):

```tut:book
val ans = for {
  a <- Eval.now { println("Calculating A"); 40 }
  b <- Eval.always { println("Calculating B"); 2 }
} yield {
  println("Adding A and B")
  a + b
}

ans.value // первый вызов
ans.value // второй вызов
```

У `Eval` есть метод `memoize`, который
позволяет мемоизировать последовательность вычислений.
Результат последовательности до вызова `memoize` кэшируется,
в то время как вычисления после вызова сохраняют свою первоначальную семантику:

```tut:book
val saying = Eval.
  always { println("Step 1"); "The cat" }.
  map { str => println("Step 2"); s"$str sat on" }.
  memoize.
  map { str => println("Step 3"); s"$str the mat" }

saying.value // первый вызов
saying.value // второй вызов
```

### *Eval.defer*

Одно из полезных свойств `Eval` является то,
что его методы `map` и `flatMap` являются *отложенными*.
Это означает, что можно применять вложенные `map` и `flatMap` произвольно, 
без необходимости использования стекового кадра (фрейма).
Мы называем это свойство *стековая безопасность (stack safety)*.

Например, рассмотрим эту функцию для рассчёта факториалов:

```tut:book:silent
def factorial(n: BigInt): BigInt =
  if(n == 1) n else n * factorial(n - 1)
```

Относительно легко сделать так, чтобы этот метод переполнил стек:

```scala
factorial(50000)
// java.lang.StackOverflowError
//   ...
```

Мы можем переписать метод, используя `Eval`, чтобы не переполнить стек:

```tut:book:silent
def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    factorial(n - 1).map(_ * n)
  }
```

```scala
factorial(50000).value
// java.lang.StackOverflowError
//   ...
```

Упс! Это не сработало — наш стек всё ещё переполнен!
Это потому, что мы всё еще делаем все рекурсивные вызовы `factorial`
до того, как начинаем работать с методом `map` у `Eval`.
Мы можем поработать над этим, используя метод `Eval.defer`,
который берёт существующий экземпляр `Eval` и откладывает его вычисление.
Метод `defer` *отложенный* как `map` и `flatMap`,
поэтому мы можем использовать его как быстрый способ сделать существующую операцию, не переполняя стек:

```tut:book:silent
def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    Eval.defer(factorial(n - 1).map(_ * n))
  }
```

```tut:book
factorial(50000).value
```

`Eval` является полезным инструментом для обеспечения стековой безопасности
при работе с очень большими вычислениями и структурами данных.
Тем не менее, мы должны помнить, что это не бесплатно.
Это позволяет избежать потребления стека, создавая последовательность функциональных объектов в куче (heap).
Всё еще есть пределы на то, как глубоко мы можем вкладывать вычисления,
но они ограничены размером кучи, а не стека.

### Упражнение: Безопасная свёртка, используя Eval

Наивная реализация `foldRight`, представленная ниже, переполняет стек.
Перепишите это, используя `Eval`:

```tut:book:silent
def foldRight[A, B](as: List[A], acc: B)(fn: (A, B) => B): B =
  as match {
    case head :: tail =>
      fn(head, foldRight(tail, acc)(fn))
    case Nil =>
      acc
  }
```

<div class="solution">
Самый простой способ это исправить —
написать вспомогательный метод под названием `foldRightEval`.
Это, по сути, наш оригинальный метод,
с каждым появлением `B` заменённым на `Eval[B]`,
и вызовом `Eval.defer` для защиты рекурсивного вызова:

```tut:book:silent
import cats.Eval

def foldRightEval[A, B](as: List[A], acc: Eval[B])
    (fn: (A, Eval[B]) => Eval[B]): Eval[B] =
  as match {
    case head :: tail =>
      Eval.defer(fn(head, foldRightEval(tail, acc)(fn)))
    case Nil =>
      acc
  }
```

Можно переопределить `foldRight` просто в терминах `foldRightEval`
и получить метод, который безопасен для стека:

```tut:book:silent
def foldRight[A, B](as: List[A], acc: B)(fn: (A, B) => B): B =
  foldRightEval(as, Eval.now(acc)) { (a, b) =>
    b.map(fn(a, _))
  }.value
```

```tut:book
foldRight((1 to 100000).toList, 0L)(_ + _)
```
</div>
