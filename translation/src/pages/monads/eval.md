## Монада «Eval» {#sec:monads:eval}

[`cats.Eval`][cats.Eval] — это монада, которая позволяет
абстрагироваться над разными *моделями вычисления*.
Обычно выделяют две модели вычислений: *энергичная* и *ленивая*.
`Eval` описывает различия между тем,
*мемоизирован* результат или нет.

### Энергичные, Ленивые, Мемоизированные, подумать только!

Что означают эти термины?

*Энергичные* вычисления происходят немедленно,
тогда как *ленивые* происходят непосредственно при вызове вычисления.
*Мемоизированные* вычисления запускаются один раз при первом вызове,
после которого результаты кэшируются.

Например, `val` в Scala энергичные и мемоизированные.
Это можно наблюдать при выполнении вычислений с видимым побочным эффектом.
В следующем примере
код для вычисления значения `x`
вызывается в месте определения,
а не при обращении к нему (энергичный).
Доступ к `x` вызывает сохраненное значение
без повторного вычисления (мемоизированный).

```tut:book
val x = {
  println("Computing X")
  math.random
}

x // первый вызов
x // второй вызов
```

В отличие от `val`, `def` ленивые и не мемоизированные.
Код для вычисления `y`, представленный ниже,
не будет выполнен до тех пор, пока в другом месте не потребуется значение `y` (ленивый),
и будет повторно выполнен при каждом вызове (не мемоизированный):

```tut:book
def y = {
  println("Computing Y")
  math.random
}

y // первый вызов
y // второй вызов
```

И последнее, но не менее важное,
`lazy val` ленивые и мемоизированные.
Код для вычисления `z`, представленный ниже,
не будет выполнен до первого обращения к его значению (ленивый).
После первого обращения результат кэшируется
и переиспользуется при последующих вызовах (мемоизированный):

```tut:book
lazy val z = {
  println("Computing Z")
  math.random
}

z // первый вызов
z // второй вызов
```

### Модели вычисления Eval

У `Eval` есть три подтипа: `Now`, `Later`, и `Always`.
Их инициализируют с помощью трёх методов,
которые создают экземпляры этих трёх классов
и возвращают их как тип `Eval`:

```tut:book:silent
import cats.Eval
```

```tut:book
val now = Eval.now(math.random + 1000)
val later = Eval.later(math.random + 2000)
val always = Eval.always(math.random + 3000)
```

Мы можем извлечь результат `Eval`,
используя метод `value`:

```tut:book
now.value
later.value
always.value
```

Каждый тип `Eval` вычисляет результат,
используя одну из определенных выше моделей вычисления.
`Eval.now` вычисляет значение *прямо сейчас*.
Его семантика похожа на `val` — энергичный и мемоизированный:

```tut:book
val x = Eval.now {
  println("Computing X")
  math.random
}

x.value // первый вызов
x.value // второй вызов
```

`Eval.always` описывает ленивое вычисление,
схожее с `def`:

```tut:book
val y = Eval.always {
  println("Computing Y")
  math.random
}

y.value // первый вызов
y.value // второй вызов
```

Наконец, `Eval.later` описывает ленивое, мемоизированное вычисление,
схожее с `lazy val`:

```tut:book
val z = Eval.later {
  println("Computing Z")
  math.random
}

z.value // первый вызов
z.value // второй вызов
```

Эти три поведения вычислений подытожены ниже:

-----------------------------------------------------------------------
Scala              Cats                      Свойства
------------------ ------------------------- --------------------------
`val`              `Now`                     энергичное, мемоизированное

`lazy val`         `Later`                   ленивое, мемоизированное

`def`              `Always`                  ленивое, не мемоизированное
------------------ ------------------------- --------------------------

### Eval — это монада

Как и у всех монад, методы `map` и `flatMap` у `Eval` добавляют вычисления в последовательность.
Однако, в данном случае, последовательность хранится явно, как перечень функций.
Функции не будут вызываны, пока у `Eval` не будет вызван
метод `value`, который запрашивает результат вычислений:

```tut:book
val greeting = Eval.
  always { println("Step 1"); "Hello" }.
  map { str => println("Step 2"); s"$str world" }

greeting.value
```

Обратите внимание, что в то время как семантика
исходных экземпляров `Eval` сохраняется,
отображение функций всегда
выполняется лениво и по требованию (семантика `def`):

```tut:book
val ans = for {
  a <- Eval.now { println("Calculating A"); 40 }
  b <- Eval.always { println("Calculating B"); 2 }
} yield {
  println("Adding A and B")
  a + b
}

ans.value // первый вызов
ans.value // второй вызов
```

У `Eval` есть метод `memoize`, который
позволяет мемоизировать последовательность вычислений.
Результат последовательности до вызова `memoize` кэшируется,
в то время как вычисления после вызова сохраняют свою первоначальную семантику:

```tut:book
val saying = Eval.
  always { println("Step 1"); "The cat" }.
  map { str => println("Step 2"); s"$str sat on" }.
  memoize.
  map { str => println("Step 3"); s"$str the mat" }

saying.value // первый вызов
saying.value // второй вызов
```

### *Eval.defer*

Одно из полезных свойств `Eval` является то,
что его методы `map` и `flatMap` являются *отложенными*.
Это означает, что можно произвольным образом вкладывать вызовы `map` и `flatMap` друг в друга, 
не приводя к чрезмерному использованию стековых кадров (stack frames).
Мы называем это свойство *стековой безопасностью (stack safety)*.

Например, рассмотрим эту функцию для расчёта факториалов:

```tut:book:silent
def factorial(n: BigInt): BigInt =
  if(n == 1) n else n * factorial(n - 1)
```

Относительно легко сделать так, чтобы этот метод переполнил стек:

```scala
factorial(50000)
// java.lang.StackOverflowError
//   ...
```

Мы можем переписать метод, используя `Eval`, чтобы не переполнить стек:

```tut:book:silent
def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    factorial(n - 1).map(_ * n)
  }
```

```scala
factorial(50000).value
// java.lang.StackOverflowError
//   ...
```

Упс! Это не сработало — наш стек всё ещё переполнен!
Это потому, что мы всё еще делаем все рекурсивные вызовы `factorial`
до того, как начинаем работать с методом `map` у `Eval`.
Мы можем поработать над этим, используя метод `Eval.defer`,
который берёт существующий экземпляр `Eval` и откладывает его вычисление.
Метод `defer` *отложенный* как `map` и `flatMap`,
поэтому мы можем использовать его как быстрый способ сделать существующую операцию, не переполняя стек:

```tut:book:silent
def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    Eval.defer(factorial(n - 1).map(_ * n))
  }
```

```tut:book
factorial(50000).value
```

`Eval` является полезным инструментом для обеспечения стековой безопасности
при работе с очень большими вычислениями и структурами данных.
Тем не менее, мы должны помнить, что это не бесплатно.
Это позволяет избежать потребления стека, создавая последовательность функциональных объектов в куче (heap).
Всё еще есть пределы на то, как глубоко мы можем вкладывать вычисления,
но они ограничены размером кучи, а не стека.

### Упражнение: Безопасная свёртка, используя Eval

Наивная реализация `foldRight`, представленная ниже, не является стекобезопасной.
Перепишите её, используя `Eval`:

```tut:book:silent
def foldRight[A, B](as: List[A], acc: B)(fn: (A, B) => B): B =
  as match {
    case head :: tail =>
      fn(head, foldRight(tail, acc)(fn))
    case Nil =>
      acc
  }
```

<div class="solution">
Самый простой способ это исправить —
написать вспомогательный метод под названием `foldRightEval`.
По сути, это тот же самый метод,
но тип `B` заменён на `Eval[B]`,
и рекурсивные вызовы производятся через `Eval.defer`:

```tut:book:silent
import cats.Eval

def foldRightEval[A, B](as: List[A], acc: Eval[B])
    (fn: (A, Eval[B]) => Eval[B]): Eval[B] =
  as match {
    case head :: tail =>
      Eval.defer(fn(head, foldRightEval(tail, acc)(fn)))
    case Nil =>
      acc
  }
```

А теперь можно переопределить `foldRight` через `foldRightEval`
и получить стекобезопасный метод:

```tut:book:silent
def foldRight[A, B](as: List[A], acc: B)(fn: (A, B) => B): B =
  foldRightEval(as, Eval.now(acc)) { (a, b) =>
    b.map(fn(a, _))
  }.value
```

```tut:book
foldRight((1 to 100000).toList, 0L)(_ + _)
```
</div>
