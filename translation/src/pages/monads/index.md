# Монады {#sec:monads}

*Монады* — одна из самых распространенных абстракций в Scala.
Для многих Scala-разработчиков монады быстро становятся интуитивно понятными, 
даже если название «монады» остаётся незнакомым.

Говоря неформально, монада — это нечто такое, у чего есть конструктор и метод `flatMap`.
Все функторы, которые мы видели в последней главе — тоже монады,
включая `Option`, `List`, и `Future`.
У нас даже есть специальный синтаксис для работы с монадами: «for-выражения» (for comprehensions).
Тем не менее, несмотря на распространённость концепции,
в стандартной библиотеке Scala отсутствует
какой-либо конкретный тип для описания «вещей, к которым применим `flatMap`».
Такой тайпкласс — это одно из преимуществ, которое даёт нам библиотека Cats.

В этой главе мы глубоко вникнем в монады.
Начнем с объяснения монад на примерах, 
затем перейдем к формальному определению и реализации в Cats.
А в конце мы устроим экскурсию по некоторым интересным монадам, о существовании которых вы, возможно, не знали. 
И разумеется, сопроводим их инструкциями и примерами.

## Что такое монада?

Этот вопрос был освещён в тысяче блоговых постов, 
подкреплённых такими разнообразными объяснениями и аналогиями, как коты, 
мексиканская еда, космические костюмы, полные токсичных отходов, 
и моноиды в категории эндофункторов (что бы это ни означало).
Мы намерены решить проблему объяснения монад раз и навсегда, 
одним простым утверждением:

> Монада — это механизм для *последовательных вычислений*.

Это было легко! Проблема решена, верно?
Но опять же, в последней главе мы сказали, что функторы
являются аналогичным механизмом для тех же вещей.
Ладно, может, нам нужно еще немного обсуждения...

В разделе [@sec:functors:examples]
было сказано, что функторы позволяют
упорядочить вычисления, игнорируя некоторое «усложнение».
Однако, функторы ограниченны тем, что
они допускают, чтобы это «усложнение» появилось
один раз в начале последовательности.
Они не обрабатывают дальнейшие «усложнения»
на каждом этапе последовательности.

Вот где монады вступают в дело.
Их метод `flatMap` позволяет определить что будет дальше,
учитывая промежуточное «усложнение».
Метод `flatMap` у `Option` работает с промежуточным `Option`.
Метод `flatMap` у `List` обрабатывает промежуточный `List`. И так далее.
В каждом случае, функция, передаваемая во `flatMap`, определяет
зависящую от области применения часть вычисления,
и сам `flatMap` избавляется от «усложнения»,
позволяя применить `flatMap` ещё раз.
Давайте внесём ясность, посмотрев на некоторые примеры.

**Options**

`Option` позволяет упорядочить вычисления,
которые могут возвращать или не возвращать значения.
Вот несколько примеров:

```tut:book:silent
def parseInt(str: String): Option[Int] =
  scala.util.Try(str.toInt).toOption

def divide(a: Int, b: Int): Option[Int] =
  if(b == 0) None else Some(a / b)
```

Каждый из этих методов может "упасть", возвращая `None`.
Метод `flatMap` позволяет игнорировать это,
когда мы описываем последовательность таких операций:

```tut:book:silent
def stringDivideBy(aStr: String, bStr: String): Option[Int] =
  parseInt(aStr).flatMap { aNum =>
    parseInt(bStr).flatMap { bNum =>
      divide(aNum, bNum)
    }
  }
```

Нам хорошо известна семантика:

- первый вызов `parseInt` возвращает `None` или `Some`;
- если он вернёт `Some`, метод `flatMap` вызывает функцию и передает целое число `aNum`;
- второй вызов `parseInt` возвращает `None` или `Some`;
- если он вернёт `Some`, метод `flatMap` вызывает функцию и передает целое число `bNum`;
- вызов `divide` возвращает `None` или `Some`, который и будет результатом.

На каждом шаге `flatMap` выбирает, вызывать ли функцию,
которая формирует следующее вычисление в последовательности.
Это показано на рисунке [@fig:monads:option-type-chart].

![Типовая диаграмма: flatMap для Option](src/pages/monads/option-flatmap.pdf+svg){#fig:monads:option-type-chart}

Результатом вычисления является `Option`,
позволяющий вызывать `flatMap` ещё раз, таким образом продолжая последовательность.
Это приводит к раннему завершению при возникновении ошибок (fail-fast), которое мы знаем и любим,
при котором появление `None` на любом этапе приводит к получению `None` в итоге:

```tut:book
stringDivideBy("6", "2")
stringDivideBy("6", "0")
stringDivideBy("6", "foo")
stringDivideBy("bar", "2")
```

Каждая монада является функтором (см доказательство ниже),
так что мы можем использовать и `flatMap`, и `map`,
для упорядочивания вычислений,
которые представляют и не представляют новую монаду.
В дополнение к этому, если у нас есть как `flatMap`, так и `map`,
мы можем использовать for-выражения
для более ясного и выразительного описания последовательности:

```tut:book:silent
def stringDivideBy(aStr: String, bStr: String): Option[Int] =
  for {
    aNum <- parseInt(aStr)
    bNum <- parseInt(bStr)
    ans  <- divide(aNum, bNum)
  } yield ans
```

**Lists**

Когда мы, будучи начинающими Scala-разработчиками, впервые сталкиваемся c `flatMap`,
мы склонны думать о нём как о способе итерирования по значениям в `List`.
Это усугубляется синтаксисом for-выражений,
которые выглядят совсем как императивные циклы `for`:

```tut:book
for {
  x <- (1 to 3).toList
  y <- (4 to 5).toList
} yield (x, y)
```

Но мы можем воспользоваться и другой ментальной моделью,
которая подчёркнёт монадическое поведение `List`.
Если рассматривать списки как наборы промежуточных результатов,
`flatMap` будет выражать вычисление их перестановок и комбинаций.

Например, в приведённом выше for-выражении
возможны три значения `x` и два значения `y`.
Это означает, что существует шесть возможных значений `(x, y)`.
`flatMap` генерирует эти комбинации из нашего кода,
который устанавливает последовательность действий:

- получить `x`
- получить `y`
- создать кортеж `(x, y)`

<!--
Типовая диаграмма на рисунке [@fig:monads:list-type-chart]
иллюстрирует это поведение[^list-lengths].

![Типовая диаграмма: flatMap для List](src/pages/monads/list-flatmap.pdf+svg){#fig:monads:list-type-chart}

[^list-lengths]: Хотя результат `flatMap` (`List[B]`)
имеет тот же тип, что и результат выполнения пользовательской функции,
конечный результат на самом деле представляет собой больший список,
созданный из комбинаций промежуточных листов типов `A` и `B`.
-->

**Futures**

`Future` — это монада, которая упорядочивает вычисления,
не беспокоясь о том, что они асинхронные:

```tut:book:silent
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._

def doSomethingLongRunning: Future[Int] = ???
def doSomethingElseLongRunning: Future[Int] = ???

def doSomethingVeryLongRunning: Future[Int] =
  for {
    result1 <- doSomethingLongRunning
    result2 <- doSomethingElseLongRunning
  } yield result1 + result2
```

Еще раз, мы описываем код, который должен быть выполнен на каждом шаге,
а `flatMap` позаботится обо всех ужасающих
внутренних сложностях пула потоков и планировщиков.

Если вы часто использовали `Future`,
то уже знаете, что вышеприведенный код 
выполняет каждую операцию *последовательно*.
Будет нагляднее, если мы развернём for-выражение,
чтобы показать вложенные вызовы `flatMap`:

```tut:book:silent
def doSomethingVeryLongRunning: Future[Int] =
  doSomethingLongRunning.flatMap { result1 =>
    doSomethingElseLongRunning.map { result2 =>
      result1 + result2
    }
  }
```

Каждая `Future` в последовательности создана
функцией, которая принимает результат из предыдущей `Future`.
Другими словами, каждый этап вычисления может начаться 
только после завершения предыдущего этапа.
Это отражено в типовой диаграмме для `flatMap`
на рисунке [@fig:monads:future-type-chart],
где можно увидеть параметр-функцию типа `A => Future[B]`.

![Типовая диаграмма: flatMap для Future](src/pages/monads/future-flatmap.pdf+svg){#fig:monads:future-type-chart}

Разумеется, мы *можем* запускать `Future` и параллельно,
но это другая история, и будет рассказана в другой раз.
Монады — о последовательных вычислениях.

### Определение монады

Ранее мы говорили только о `flatMap`,
но формально монадическое поведение определяется двумя операциями:

- `pure`, типа `A => F[A]`;
- `flatMap`[^bind], типа `(F[A], A => F[B]) => F[B]`.

[^bind]: В некоторых библиотеках и языках,
а именно: в Scalaz и Haskell,
`pure` называется `point` или `return`, а
`flatMap` называется `bind` или `>>=`.
Различие состоит только в терминологии.
Мы будем использовать термин `flatMap` для совместимости
с Cats и стандартной библиотекой Scala.

`pure` абстрагируется над конструкторами,
предоставляя способ создания нового монадического контекста из обычного значения.
`flatMap` обеспечивает шаг последовательности, который мы уже обсудили,
извлекающий значение из контекста и формирующий
следующий контекст в последовательности.
Ниже представлена упрощённая версия тайпкласса `Monad` в Cats:

```tut:book:silent
import scala.language.higherKinds

trait Monad[F[_]] {
  def pure[A](value: A): F[A]

  def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]
}
```

<div class="callout callout-warning">
*Монадические законы*

`pure` и `flatMap` должны подчиняться законам,
которые позволяют нам свободно упорядочивать операции
без непреднамеренных сбоев и побочных эффектов:

*Левая тождественность*: применить `pure`
и преобразовать результат с помощью `func`,
это то же самое, что просто применить `func`:

```scala
pure(a).flatMap(func) == func(a)
```

*Правая тождественность*: передать `pure` во `flatMap`,
это то же самое, что ничего не делать с исходным значением:

```scala
m.flatMap(pure) == m
```

*Ассоциативность*: применить `flatMap` к двум функциям `f` и `g`,
это то же самое, что и применить `flatMap` к `f` и, затем, применить `flatMap` к `g`:

```scala
m.flatMap(f).flatMap(g) == m.flatMap(x => f(x).flatMap(g))
```
</div>

### Упражнение: Применяем func-ции.

Каждая монада также является функтором.
Мы можем определить `map` одинаково для каждой монады,
используя существующие методы `flatMap` и `pure`:

```tut:book:silent
import scala.language.higherKinds

trait Monad[F[_]] {
  def pure[A](a: A): F[A]

  def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]

  def map[A, B](value: F[A])(func: A => B): F[B] =
    ???
}
```

Сейчас попробуйте определить `map` самостоятельно.

<div class="solution">
На первый взгляд, это кажется запутанным,
но если следовать типам, мы увидим только одно решение.
Нам передали `value` типа `F[A]`.
Учитывая доступные средства, мы можем сделать только одно:
применить `flatMap`:

```tut:book:silent
trait Monad[F[_]] {
  def pure[A](value: A): F[A]

  def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]

  def map[A, B](value: F[A])(func: A => B): F[B] =
    flatMap(value)(a => ???)
}
```

Вторым параметром нам нужна функция типа `A => F[B]`.
У нас есть два функциональных блока:
параметр `func` типа `A => B`
и функция `pure` типа `A => F[A]`.
Объединив их, получаем результат:

```tut:book:silent
trait Monad[F[_]] {
  def pure[A](value: A): F[A]

  def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]

  def map[A, B](value: F[A])(func: A => B): F[B] =
    flatMap(value)(a => pure(func(a)))
}
```
</div>
