## The State Monad

[`cats.data.State`][cats.data.State]
позволяет передавать дополнительное состояние в рамках вычисления.
Экземпляры `State` представляют собой атомарные операции состояния,
которые связывают между собой с помощью `map` и `flatMap`.
Таким образом, мутабельное состояние можно представить в функциональном стиле,
без использования мутабельности.

### Создаём и Извлекаем Состояние

Сокращённые до их самой простой формы,
экземпляры `State[S, A]` представляют собой функции типа `S => (S, A)`.
`S` — это тип состояния и `A` — это тип результата.

```tut:book:silent
import cats.data.State
```

```tut:book
val a = State[Int, String] { state =>
  (state, s"The state is $state")
}
```

Другими словами, экземпляр `State` — это функция,
которая делает две вещи:

- преобразует состояние входа в состояние выхода;
- вычисляет результат.

Можно "запустить" монаду, предоставив начальное состояние.
`State` предоставляет три метода — `run`, `runS`, и `runA`, которые возвращает
различные комбинации состояния и результата.
Каждый метод возвращает экземпляр `Eval`,
который `State` использует для сохранения стековой безопасности.
Чтобы извлечь актуальное значение, можно вызвать метод `value`:

```tut:book
// Получить состояние и результат:
val (state, result) = a.run(10).value

// Получить состояние, игнорировать результат:
val state = a.runS(10).value

// Получить результат, игнорировать состояние:
val result = a.runA(10).value
```

### Композиция и Преобразование Состояния

Как мы видели на примере `Reader` и `Writer`,
сила монады `State` в возможности композиции экземпляров.
Методы `map` и `flatMap` передают состояние от одного экземпляра к другому.
Каждый отдельный экземпляр представляет собой атомарное преобразование состояния,
а их композиция представляет собой последовательность всех изменений:

```tut:book
val step1 = State[Int, String] { num =>
  val ans = num + 1
  (ans, s"Result of step1: $ans")
}

val step2 = State[Int, String] { num =>
  val ans = num * 2
  (ans, s"Result of step2: $ans")
}

val both = for {
  a <- step1
  b <- step2
} yield (a, b)

val (state, result) = both.run(20).value
```

Можно заметить, в данном примере конечное состояние
является результатом последовательного применения двух преобразований.
Состояние передаётся от шага к шагу,
хотя мы и не взаимодействуем с ним в for-выражении.

Общая модель использования монады `State`
заключается в представлении каждого шага вычисления как экземпляра
и композиции шагов, используя стандартные операторы монад.
Cats предоставлет несколько удобных конструкторов для создания простых шагов:

  - `get` извлекает состояние и возвращает его в результате;
  - `set` обновляет состояние и возвращает `unit` в результате;
  - `pure` игнорирует состояние и возвращает предоставленный результат;
  - `inspect` извлекает состояние с помощью функции преобразования;
  - `modify` обновляет состояние с помощью функции обновления.

```tut:book
val getDemo = State.get[Int]
getDemo.run(10).value

val setDemo = State.set[Int](30)
setDemo.run(10).value

val pureDemo = State.pure[Int, String]("Result")
pureDemo.run(10).value

val inspectDemo = State.inspect[Int, String](_ + "!")
inspectDemo.run(10).value

val modifyDemo = State.modify[Int](_ + 1)
modifyDemo.run(10).value
```

Можно собрать эти преобразования, используя for-выражения.
Обычно мы игнорируем результат промежуточных этапов,
которые представляют только преобразования состояния:

```tut:book:silent
import State._
```

```tut:book
val program: State[Int, (Int, Int, Int)] = for {
  a <- get[Int]
  _ <- set[Int](a + 1)
  b <- get[Int]
  _ <- modify[Int](_ + 1)
  c <- inspect[Int, Int](_ * 1000)
} yield (a, b, c)

val (state, result) = program.run(1).value
```

### Упражнение: Калькулятор с обратной польской записью

Монада `State` позволяет нам реализовать
простые интерпретаторы для сложных выражений,
передавая значения мутабельных регистров вместе с результатом.
Рассмотрим простой пример этого, реализовав
калькулятор с помощью алгоритма «обратной польской записи» (Reverse Polish notation) для целочисленных арифметических вычислений.

На случай, если вы не слышали об «обратной польской записи» до этого, 
(не волнуйтесь, если не слышали),
она представляет собой математическую запись,
где оператор записывается *после* его операндов.
Итак, например, вместо того, чтобы написать `1 + 2` мы напишем:

```scala
1 2 +
```

Хотя человеку сложно читать записанные таким образом выражения,
их легко вычислять в коде.
Всё, что нужно сделать — это обойти все символы выражения слева направо,
имея с собой *стек* операндов по мере обхода:

- когда мы видим число, добавляем его в стек;

- когда мы видим оператор, извлекаем два операнда из стека,
  применяем операцию, и записываем результат в стек.

Это позволяет вычислять сложные выражения без использования скобок.
Например, можно вычислить выражение `(1 + 2) * 3)` следующим образом:

```scala
1 2 + 3 * // видим 1, добавляем в стек
2 + 3 *   // видим 2, добавляем в стек
+ 3 *     // видим +, извлекаем 1 и 2 из стека,
          //          добавляем (1 + 2) = 3 на их место
3 3 *     // видим 3, добавляем в стек
3 *       // видим 3, добавляем в стек
*         // видим *, извлекаем 3 и 3 из стека,
          //          добавляем (3 * 3) = 9 на их место
```

Давайте напишем интерпретатор для этих выражений.
Мы можем считывать каждый символ в экземпляр `State`,
представляющий собой преобразование в стеке 
и промежуточный результат.
Экземпляры `State` могут быть скомпозированы, используя `flatMap`,
для создания интерпретатора из любой последовательности символов.

Начните с написания функции `evalOne`, которая
считывает каждый символ в экземпляр `State`.
Используйте код ниже как шаблон.
Не волнуйтесь об обработке ошибок, если
стек неправильно настроен,
можно бросить исключение.

```tut:book:reset:silent
import cats.data.State

type CalcState[A] = State[List[Int], A]

def evalOne(sym: String): CalcState[Int] = ???
```

Если это кажется сложным,
подумайте о простой форме экземпляра `State`, который возвращается.
Каждый экземпляр представляет собой функциональное преобразование значений
из «текущего» стека в пару «нового» стека и результата.
Можно игнорировать любой более широкий контекст вышесказанного и сосредоточиться только этом определении:

```tut:book:invisible
def someTransformation(input: List[Int]): List[Int] = input
def someCalculation: Int = 123
```

```tut:book:silent
State[List[Int], Int] { oldStack =>
  val newStack = someTransformation(oldStack)
  val result   = someCalculation
  (newStack, result)
}
```

Не стесняйтесь написать собственный экземпляр `Stack` в таком виде
или как последовательность удобных конструкторов, как в примере выше.

<div class="solution">
Требуемая операция стека отличается для операторов и операндов.
Для ясности, реализуем `evalOne` в виде двух вспомогательных функций,
по одному на каждый случай:

```scala
def evalOne(sym: String): CalcState[Int] =
  sym match {
    case "+" => operator(_ + _)
    case "-" => operator(_ - _)
    case "*" => operator(_ * _)
    case "/" => operator(_ / _)
    case num => operand(num.toInt)
  }
```

Во-первых, рассмотрим `operand`.
Все, что нам нужно сделать, это добавить число в стек.
Мы также возвращаем операнд как промежуточный результат:

```tut:book:silent
def operand(num: Int): CalcState[Int] =
  State[List[Int], Int] { stack =>
    (num :: stack, num)
  }
```

Функция `operator` немного сложнее.
Мы должны получить два операнда из стека (имея второй операнд наверху стека) и положить результат на их место.
Код может завершиться неудачно, если в стеке не достаточно операндов,
но в упражнении сказано, что в таком случаем можно бросить исключение:

```tut:book:silent
def operator(func: (Int, Int) => Int): CalcState[Int] =
  State[List[Int], Int] {
    case b :: a :: tail =>
      val ans = func(a, b)
      (ans :: tail, ans)

    case _ =>
      sys.error("Fail!")
  }
```

```tut:book:invisible
def evalOne(sym: String): CalcState[Int] =
  sym match {
    case "+" => operator(_ + _)
    case "-" => operator(_ - _)
    case "*" => operator(_ * _)
    case "/" => operator(_ / _)
    case num => operand(num.toInt)
  }
```
</div>

`evalOne` позволяет вычислять односимвольные выражения следующим образом.
Вызовем `runA`, предоставляя `Nil`, как начальное значение для стека,
и вызовем `value`, чтобы получить результат экземпляра `Eval`:

```tut:book
evalOne("42").runA(Nil).value
```

Мы можем писать более сложные программы, используя `evalOne`, `map`, и `flatMap`.
Обратите внимание, что большая часть работы происходит на стеке,
поэтому мы игнорируем результаты промежуточных шагов для `evalOne("1")` и `evalOne("2")`:

```tut:book
val program = for {
  _   <- evalOne("1")
  _   <- evalOne("2")
  ans <- evalOne("+")
} yield ans

program.runA(Nil).value
```

Обобщите этот пример, написав метод `evalAll`,
который вычисляет результат `List[String]`.
Используйте `evalOne` для обработки каждого символа,
и связывания результатов монад `State`, используя `flatMap`.
Ваша функция должна иметь следующую сигнатуру:

```tut:book:silent
def evalAll(input: List[String]): CalcState[Int] =
  ???
```

<div class="solution">
Реализуем `evalAll`, применяя операцию «свёртки» к списку.
Начнём с «чистого» `CalcState`, который возвращает `0`, если лист пустой.
Применяем `flatMap` на каждом этапе,
игнорируя промежуточные результаты, как было описано ранее:

```tut:book:silent
import cats.syntax.applicative._ // for pure

def evalAll(input: List[String]): CalcState[Int] =
  input.foldLeft(0.pure[CalcState]) { (a, b) =>
    a.flatMap(_ => evalOne(b))
  }
```

</div>

Можно использовать `evalAll`, чтобы удобно вычислять многоэтапные вычисления:

```tut:book
val program = evalAll(List("1", "2", "+", "3", "*"))

program.runA(Nil).value
```

Из-за того, что `evalOne` и `evalAll` оба возвращают экземпляры `State`,
можно связать их результаты вместе, используя `flatMap`.
`evalOne` производит простое преобразование стека, а
`evalAll` производит сложное, но они являются чистыми функциями
и можно использовать их в любом порядке столько раз, сколько захотим:

```tut:book
val program = for {
  _   <- evalAll(List("1", "2", "+"))
  _   <- evalAll(List("3", "4", "+"))
  ans <- evalOne("*")
} yield ans

program.runA(Nil).value
```

Завершите упражнение, реализовав функцию `evalInput`, которая
разделяет входной `String` на символы, вызывает `evalAll`,
и запускает вычисление результата, имея начальное значение.

<div class="solution">
Мы проделали всю тяжелую работу.
Все, что нам нужно сделать, это разделить входные данные на символы
и вызвать `runA` и `value`, чтобы получить результат:

```tut:book:silent
def evalInput(input: String): Int =
  evalAll(input.split(" ").toList).runA(Nil).value
```

```tut:book
evalInput("1 2 + 3 4 + *")
```
</div>
