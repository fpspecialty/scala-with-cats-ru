## Монада Identity {#sec:monads:identity}

В предыдущем разделе мы видели синтаксис `flatMap` и `map` Cats
c абстрагированием типа монады:

```tut:book:silent
import scala.language.higherKinds
import cats.Monad
import cats.syntax.functor._ // for map
import cats.syntax.flatMap._ // for flatMap

def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
  for {
    x <- a
    y <- b
  } yield x*x + y*y
```

Этот метод работает для `Option` и `List`,
но не принимает простые значения в качестве аргументов:

```tut:book:fail
sumSquare(3, 4)
```

Было бы очень удобно, если бы мы cмогли использовать `sumSquare`
с любыми аргументами.
Тогда мы бы смогли писать абстрактный код, работающий как с монадами, так и без них.
К счастью, Cats предоставляет тип `Id`:

```tut:book:silent
import cats.Id
```

```tut:book
sumSquare(3 : Id[Int], 4 : Id[Int])
```

С помощью `Id` мы можем передавать в монадический метод простые значения.
Однако, сразу понять смысл таких выражений бывает сложно.
Мы преобразуем параметры `sumSquare` в `Id[Int]`
и получаем `Id[Int]` в качестве результата!

Чтобы лучше понять происходящее, рассмотрим определение `Id`:

```scala
package cats

type Id[A] = A
```

На самом деле, `Id` — это однопараметрический конструктор типа,
который преобразует любой конкретный тип `A` в другой тип (его псевдоним), 
в котором `A` является типовым параметром.
Мы можем преобразовать любое значение любого типа в соответствующий `Id`:

```tut:book
"Dave" : Id[String]
123 : Id[Int]
List(1, 2, 3) : Id[List[Int]]
```

Cats предоставляет экземпляры различных тайпклассов для `Id`,
включая `Functor` и `Monad`.
Благодаря им можно вызывать `map`, `flatMap`, и `pure`
с простыми значениями:

```tut:book
val a = Monad[Id].pure(3)
val b = Monad[Id].flatMap(a)(_ + 1)
```

```tut:book:silent
import cats.syntax.functor._ // for map
import cats.syntax.flatMap._ // for flatMap
```

```tut:book
for {
  x <- a
  y <- b
} yield x + y
```

Возможность абстрагивания монадического и не монадического кода - 
крайне мощна.
Например,
мы можем запускать код в промышленной эксплуатации асинхронно, используя`Future`,
а при тестировании - синхронно через `Id`.
Рассмотрим это на конкретном примере
в главе [@sec:case-studies:testing].

### Упражнение: Монадические Секретные Id-ентичности

Реализуйте `pure`, `map`, и `flatMap` для `Id`!
Какие интересные открытия вы обнаружите в реализации?

<div class="solution">
Начнем с определения сигнатур методов:

```tut:book:silent
import cats.Id

def pure[A](value: A): Id[A] =
  ???

def map[A, B](initial: Id[A])(func: A => B): Id[B] =
  ???

def flatMap[A, B](initial: Id[A])(func: A => Id[B]): Id[B] =
  ???
```

Теперь рассмотрим каждый метод по-очереди.
Операция `pure` создает `Id[A]` из `A`.
Но ведь `A` и `Id[A]` - один и тот же тип!
Всё, что нужно сделать - просто вернуть исходное значение:

```tut:book:silent
def pure[A](value: A): Id[A] =
  value
```

```tut:book
pure(123)
```

Метод `map` принимает параметр с типом `Id[A]`,
применяет функцию с типом `A => B`, и возвращает `Id[B]`.
Но `Id[A]` - это просто `A`, и `Id[B]` - `B`!
Достаточно вызвать функцию — в запаковке и распаковке нет необходимости:

```tut:book:silent
def map[A, B](initial: Id[A])(func: A => B): Id[B] =
  func(initial)
```

```tut:book
map(123)(_ * 2)
```

Последняя строка кода показывает,
что, как только мы убрали конструкторы `Id`,
`flatMap` и `map` оказались идентичными:

```tut:book
def flatMap[A, B](initial: Id[A])(func: A => Id[B]): Id[B] =
  func(initial)
```

```tut:book
flatMap(123)(_ * 2)
```

Это укладывается в наше понимание функторов и монад,
как тайпклассов, позволяющих организовывать последовательные вычисления.
Каждый тайпкласс позволяет объединить операции в цепочку,
игнорируя некоторое усложнение.
В случае `Id` нет усложнения,
поэтому `map` и `flatMap` - одно и то же.

Следует отметить, что нам не пришлось писать аннотации типов
в методах выше.
Компилятор может интерпретировать значения типа `A` как `Id[A]`, и наоборот,
по контексту использования.

Единственное ограничение заключается в том, что Scala не может унифицировать
типы и конструкторы типов при поиске неявных значений.
Поэтому пришлось написать `Id[Int]` вместо `Int`
в вызове `sumSquare` в начале раздела:

```tut:book:silent
sumSquare(3 : Id[Int], 4 : Id[Int])
```
</div>
