## Встречайте Cats!

В предыдущей части мы увидели, как реализованы тайпклассы в Scala.
В этой части мы увидим, как тайпклассы реализуются в Cats.

Cats написаны с помощью модульной структуры, 
которая позволяет нам выбрать, какие тайпклассы, экземпляры
и интерфейсные методы мы хотим использовать.
Давайте, например, посмотрим на [`cats.Show`][cats.Show].

В предыдущей главе мы создали тайпкласс `Printable`. `Show` - это эквивалент этого тайпкласса, определённый в Cats.
Он предоставляет механизм создания дружественного-к-разработчику консольного вывода без использования `toString`.
Ниже представлено его сокращённое определение:

```scala
package cats

trait Show[A] {
  def show(value: A): String
}
```

### Импортирование тайпклассов

Тайпклассы в Cats определены в пакете [`cats`][cats.package].
Мы можем напрямую импортировать `Show` из этого пакета:

```tut:book:silent
import cats.Show
```

Объект-компаньон каждого тайпкласса в Cats оснащён методом `apply`, 
который ищет экземпляры для любого указанного нами типа:

```tut:book:fail
val showInt = Show.apply[Int]
```

Упс---это не работает!
Метод `apply` использует *'implicit'-ы* для поиска отдельных экземпляров,
поэтому мы должны импортировать некоторые экземпляры в нашу область видимости.

### Импортирование экземпляров по умолчанию {#importing-default-instances}

Пакет [`cats.instances`][cats.instances] предоставляет готовые экземпляры для большого набора типов.
Ниже показаны примеры их импортирования.
Импортирование каждого подпакета предоставляет экземпляры всех тайпклассов из Cats
для указанного типового параметра:

- [`cats.instances.int`][cats.instances.int] предоставляет экземпляры для `Int`
- [`cats.instances.string`][cats.instances.string] предоставляет экземпляры для `String`
- [`cats.instances.list`][cats.instances.list] предоставляет экземпляры для `List`
- [`cats.instances.option`][cats.instances.option] предоставляет экземпляры для `Option`
- [`cats.instances.all`][cats.instances.all] предоставляет все экземпляры, которые поставляются вместе с Cats "из коробки"

Вы можете заглянуть в пакет [`cats.instances`][cats.instances], 
чтобы увидеть полный список подпакетов, доступных для импорта.

Давайте импортируем экземпляры тайпкласса `Show` для `Int` и `String`:

```tut:book:silent
import cats.instances.int._    // для Show
import cats.instances.string._ // для Show

val showInt:    Show[Int]    = Show.apply[Int]
val showString: Show[String] = Show.apply[String]
```

Так-то лучше! Теперь у нас есть два экземпляра тайпкласса `Show`,
которые мы можем использовать для вывода значений типов `Int` and `String` на консоль:

```tut:book
val intAsString: String =
  showInt.show(123)

val stringAsString: String =
  showString.show("abc")
```

### Импортирование интерфейсного синтаксиса

Мы можем сделать `Show` более лёгким для использования посредством
импортирования *интерфейсного синтаксиса* из [`cats.syntax.show`][cats.syntax.show].
Это добавит метод расширения `show`
к любому типу, для которого существует доступный в нашей области видимости экземпляр тайпкласса `Show`:

```tut:book:silent
import cats.syntax.show._ // для show
```

```tut:book
val shownInt = 123.show

val shownString = "abc".show
```

Cats предоставляет раздельное импортирование синтаксиса для каждого тайпкласса.
Мы познакомимся с ним в следующих главах.

### Импортировать всё что можно!

В этой книге мы будем использовать импортирование конкретных пакетов, чтобы показать
точнее, какие экземпляры и синтаксис нужны вам в каждом примере.
Но во многих случаях такой подход может отнимать много времени, 
поэтому не стесняйтесь упрощать себе импортирование следующими способами:

- `import cats._` импортирует все тайпклассы из Cats за один шаг;

- `import cats.instances.all._` импортирует все экземпляры тайпклассов для стандартной библиотеки за один шаг;

- `import cats.syntax.all._` импортирует весь синтаксис за один шаг;

- `import cats.implicits._` импортирует все стандартные экземпляры тайпклассов
  *и* весь синтаксис за один шаг.

Большинство людей начинают файлы программного кода следующими общими директивами импорта,
возвращаясь к более конкретному импортированию только если 
они сталкиваются с конфликтом имён
или с проблемами неоднозначных 'implicit'-ов:

```tut:book:silent
import cats._
import cats.implicits._
```

### Определение пользовательских экземпляров {#defining-custom-instances}

Мы можем определить экземпляр тайпкласса `Show` достаточно просто - 
посредством реализации типажа (трейта) для данного типа:

```tut:book:silent
import java.util.Date

implicit val dateShow: Show[Date] =
  new Show[Date] {
    def show(date: Date): String =
      s"${date.getTime}ms since the epoch."
  }
```

Для упрощения процесса, Cats также предоставляет
пару удобных методов.
Для определения экземпляров наших собственных, пользовательских типов мы можем использовать два метода конструирования из объекта-компаньона тайпкласса `Show`:

```scala
object Show {
  // Преобразование функции в экземпляр тайпкласса `Show`:
  def show[A](f: A => String): Show[A] =
    ???

  // Создание экземпляра тайпкласса `Show` из метода `toString`:
  def fromToString[A]: Show[A] =
    ???
}
```

Эти методы позволяют нам быстро создавать экземпляры - 
с меньшим числом "приседаний" по сравнению с созданием "с нуля":

```tut:book:silent
implicit val dateShow: Show[Date] =
  Show.show(date => s"${date.getTime}ms since the epoch.")
```

Как вы можете заметить, при использовании конструирующих методов код получается 
намного более лаконичным.
Многие тайпклассы из Cats предоставляют методы-"помощники", подобные представленным выше,
для создания экземпляров "с нуля" или через преобразование существующих экземпляров для других типов.

### Упражнение: Cat Show

Реализуйте заново приложение `Cat` из предыдущей главы,
используя тайпкласс `Show` вместо `Printable`.

<div class="solution">
Для начала, давайте импортируем всё, что нам нужно, из Cats:
тайпкласс `Show`,
экземпляры для `Int` и `String`,
и интерфейсный синтаксис:

```tut:book:silent
import cats.Show
import cats.instances.int._    // для Show
import cats.instances.string._ // для Show
import cats.syntax.show._      // для show
```

Наше опредение `Cat` остаётся прежним:

```tut:book:silent
final case class Cat(name: String, age: Int, color: String)
```

Заменим наш `Printable` экземпляром тайпкласса `Show` в объекте-компаньоне, 
используя одно из определений методов-"помощников", обсуждавшихся выше:

```tut:book:silent
implicit val catShow = Show.show[Cat] { cat =>
  val name  = cat.name.show
  val age   = cat.age.show
  val color = cat.color.show
  s"$name is a $age year-old $color cat."
}
```

В конце, чтобы "распечатать" наш экземпляр типа `Cat`, мы используем интерфейсный синтаксис тайпкласса `Show`:

```tut:book
println(Cat("Garfield", 38, "ginger and black").show)
```
</div>
