## Встречайте Cats!

В предыдущей части мы увидели, как реализуются тайпклассы в Scala.
В этой части мы увидим, как тайпклассы реализованы в Cats.

Cats написаны с помощью модульной структуры, 
которая позволяет нам выбрать, какие тайпклассы, экземпляры
и интерфейсные методы мы хотим использовать.
Давайте, например, посмотрим на [`cats.Show`][cats.Show].

В предыдущей главе мы создали тайпкласс `Printable`. `Show` является эквивалентом этого тайпкласса, определённым в Cats.
Он предоставляет удобный способ вывода на консоль без использования `toString`.
Ниже представлено его сокращённое определение:

```scala
package cats

trait Show[A] {
  def show(value: A): String
}
```

### Импортирование тайпклассов

Тайпклассы в Cats определены в пакете [`cats`][cats.package].
Мы можем напрямую импортировать `Show` из этого пакета:

```tut:book:silent
import cats.Show
```

Объект-компаньон каждого тайпкласса в Cats оснащён методом `apply`, 
который ищет экземпляры для любого указанного нами типа:

```tut:book:fail
val showInt = Show.apply[Int]
```

Упс — это не работает!
Метод `apply` использует *неявные параметры* для поиска отдельных экземпляров,
поэтому мы должны импортировать некоторые экземпляры в нашу область видимости.

### Импортирование экземпляров по умолчанию {#importing-default-instances}

Пакет [`cats.instances`][cats.instances] предоставляет готовые экземпляры для большого набора типов.
Ниже показаны примеры их импортирования.
Импортирование каждого подпакета предоставляет экземпляры всех тайпклассов из Cats
для указанного типа:

- [`cats.instances.int`][cats.instances.int] предоставляет экземпляры для `Int`
- [`cats.instances.string`][cats.instances.string] предоставляет экземпляры для `String`
- [`cats.instances.list`][cats.instances.list] предоставляет экземпляры для `List`
- [`cats.instances.option`][cats.instances.option] предоставляет экземпляры для `Option`
- [`cats.instances.all`][cats.instances.all] предоставляет все экземпляры, которые есть в составе Cats

Вы можете заглянуть в пакет [`cats.instances`][cats.instances], 
чтобы увидеть полный список подпакетов, доступных для импорта.

Давайте импортируем экземпляры тайпкласса `Show` для `Int` и `String`:

```tut:book:silent
import cats.instances.int._    // для Show
import cats.instances.string._ // для Show

val showInt:    Show[Int]    = Show.apply[Int]
val showString: Show[String] = Show.apply[String]
```

Так-то лучше! Теперь у нас есть два экземпляра тайпкласса `Show`,
которые мы можем использовать для вывода значений типов `Int` and `String` на консоль:

```tut:book
val intAsString: String =
  showInt.show(123)

val stringAsString: String =
  showString.show("abc")
```

### Импортирование интерфейсного синтаксиса

Мы можем сделать `Show` более лёгким для использования посредством
импортирования *интерфейсного синтаксиса* из [`cats.syntax.show`][cats.syntax.show].
Это добавит метод расширения `show`
к любому типу, для которого существует доступный в нашей области видимости экземпляр тайпкласса `Show`:

```tut:book:silent
import cats.syntax.show._ // для show
```

```tut:book
val shownInt = 123.show

val shownString = "abc".show
```

Cats предоставляет раздельное импортирование синтаксиса для каждого тайпкласса.
Мы познакомимся с ним в следующих главах.

### Импортируем всё!

В этой книге мы будем использовать импортирование конкретных пакетов, чтобы показать
точнее, какие экземпляры и синтаксис нужны вам в каждом примере.
Но во многих случаях такой подход может отнимать много времени, 
поэтому не стесняйтесь упрощать себе импортирование следующими способами:

- `import cats._` импортирует все тайпклассы из Cats за один шаг;

- `import cats.instances.all._` импортирует все экземпляры тайпклассов для стандартной библиотеки за один шаг;

- `import cats.syntax.all._` импортирует весь синтаксис за один шаг;

- `import cats.implicits._` импортирует все стандартные экземпляры тайпклассов
  *и* весь синтаксис за один шаг.

Большинство людей начинают файлы программного кода следующими общими директивами импорта,
возвращаясь к более конкретному импортированию только если 
они сталкиваются с конфликтом имён
или с проблемами неоднозначно определённых значений неявных параметров:

```tut:book:silent
import cats._
import cats.implicits._
```

### Определение пользовательских экземпляров {#defining-custom-instances}

Мы можем определить экземпляр тайпкласса `Show` достаточно просто — 
посредством реализации трейта для данного типа:

```tut:book:silent
import java.util.Date

implicit val dateShow: Show[Date] =
  new Show[Date] {
    def show(date: Date): String =
      s"${date.getTime}ms since the epoch."
  }
```

Для упрощения процесса, Cats также предоставляет
пару удобных методов.
Чтобы определить экземпляр тайпкласса для наших собственных, пользовательских типов, мы можем воспользоваться одним из двух методов, которые предоставляет объект-компаньон тайпкласса `Show`:

```scala
object Show {
  // Определение экземпляра тайпкласса `Show` на основе произвольной функции:
  def show[A](f: A => String): Show[A] =
    ???

  // Определение экземпляра тайпкласса `Show` на основе метода `toString`:
  def fromToString[A]: Show[A] =
    ???
}
```

Эти методы позволяют нам быстро создавать экземпляры — 
проще, чем по сравнению с созданием «с нуля»:

```tut:book:silent
implicit val dateShow: Show[Date] =
  Show.show(date => s"${date.getTime}ms since the epoch.")
```

Как вы можете заметить, при использовании конструирующих методов код получается 
намного более лаконичным.
Многие тайпклассы из Cats предоставляют вспомогательные методы, подобные представленным выше,
для создания экземпляров «с нуля» или через преобразование существующих экземпляров для других типов.

### Упражнение: Cat Show

Реализуйте заново приложение `Cat` из предыдущей главы,
используя тайпкласс `Show` вместо `Printable`.

<div class="solution">
Для начала, давайте импортируем всё, что нам нужно, из Cats:
тайпкласс `Show`,
экземпляры для `Int` и `String`,
и интерфейсный синтаксис:

```tut:book:silent
import cats.Show
import cats.instances.int._    // для Show
import cats.instances.string._ // для Show
import cats.syntax.show._      // для show
```

Наше определение типа `Cat` остаётся прежним:

```tut:book:silent
final case class Cat(name: String, age: Int, color: String)
```

Заменим наш `Printable` экземпляром тайпкласса `Show` в объекте-компаньоне, 
используя одно из определений вспомогательных методов, обсуждавшихся выше:

```tut:book:silent
implicit val catShow = Show.show[Cat] { cat =>
  val name  = cat.name.show
  val age   = cat.age.show
  val color = cat.color.show
  s"$name is a $age year-old $color cat."
}
```

В конце, чтобы «распечатать» наш экземпляр типа `Cat`, мы используем интерфейсный синтаксис тайпкласса `Show`:

```tut:book
println(Cat("Garfield", 38, "ginger and black").show)
```
</div>
