## Итог

В этой главе мы познакомились с тайпклассами.
Мы реализовали наш собственный тайпкласс `Printable`, используя чистую Scala, 
а уже после этого рассмотрели два примера из Cats: `Show` и `Eq`.

Теперь нам известны общие закономерности тайпклассов в Cats:

 - Сами тайпклассы являются обобщёнными трейтами 
   в пакете [`cats`][cats.package].

 - Каждый тайпкласс имеет объект-компаньон 
   с методом `apply` для «материализации» экземпляров, 
   одним или несколькими методами для создания собственных экземпляров 
   и набором прочих вспомогательных методов.

 - Предопределённые экземпляры содержатся в объектах 
   в пакете [`cats.instances`][cats.instances] 
   и сгруппированы по типу, для которого определён экземпляр, а не по тайпклассу.

 - Для многих тайпклассов существует *синтаксис*, предоставляемый в пакете [`cats.syntax`][cats.syntax].

В оставшихся главах Части I 
мы рассмотрим несколько обширных и мощных тайпклассов: 
`Semigroup`, `Monoid`, `Functor`, `Monad`, `Semigroupal`, `Applicative`, `Traverse` и другие.
Про каждый тайпкласс мы узнаем, какие функциональные возможности он предоставляет, 
каким законам он подчиняется, и как он реализован в Cats.
Многие из этих тайпклассов значительно более абстрактны, чем `Show` или` Eq`.
С одной стороны, это делает их освоение трудным, 
а с другой — делает их гораздо более полезными для решения общих проблем.
