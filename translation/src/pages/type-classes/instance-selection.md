## Управление выбором экземпляра

При работе с тайпклассами 
мы должны помнить о двух аспектах, 
которые управляют выбором экземпляра:

 -  В каких отношениях находятся экземпляр, 
    определенный для типа, и его подтипы?

    Например, если мы определим `JsonWriter[Option[Int]]`, 
    выберет ли выражение `Json.toJson(Some(1))` этот экземпляр?
    (Помните, что `Some` является подтипом `Option`).

 -  Как нам выбирать между подходящими экземплярами тайпклассов, 
    когда нам доступно сразу несколько?

    Что, если мы определим два экземпляра `JsonWriter` для `Person`?
    Какой экземпляр будет выбран, 
    если мы напишем `Json.toJson(aPerson)`?

### Вариантность {#sec:variance}

Когда мы определяем тайпклассы,
мы можем добавлять аннотации вариантности к типовым параметрам,
чтобы влиять на вариантность тайпкласса
и способность компилятора подбирать экземпляры
в процессе подстановки значений неявных параметров.

Как было изложено в книге Essential Scala,
понятие вариантности связано с отношением подтипирования.
Мы говорим, что `B` является подтипом `A`,
если мы можем использовать значение типа `B` везде,
где ожидается значение типа `A`.

Ковариантные и контравариантные аннотации
встречаются при работе с конструкторами типов.
Например, ковариантность обозначается символом `+`:

```scala
trait F[+A] // «+» означает «ковариантный»
```

**Ковариантность**

Ковариантность означает, что тип `F[B]`
является подтипом типа `F[A]`, если `B` является подтипом `A`.
Это полезно для моделирования многих типов,
включая коллекции, такие как `List` и `Option`:

```scala
trait List[+A]
trait Option[+A]
```

Ковариантность коллекций Scala позволяет нам
подставлять коллекции одного типа вместо коллекций другого типа.
Например, мы можем использовать `List[Circle]` везде,
где мы ожидаем `List[Shape]`,
потому что `Circle` является подтипом `Shape`:

```tut:book:silent
sealed trait Shape
case class Circle(radius: Double) extends Shape
```

```scala
val circles: List[Circle] = ???
val shapes: List[Shape] = circles
```

```tut:book:invisible
val circles: List[Circle] = null
val shapes: List[Shape] = circles
```

А как насчет контравариантности?
Мы помечаем контравариантные конструкторы типов символом `-` следующим образом:

```scala
trait F[-A]
```

**Контравариантность**

Сперва это может показаться странным, но контравариантность означает,
что тип `F[B]` является подтипом `F[A]`, если `A` является подтипом `B`.
Это полезно для моделирования типов, которые выражают обработку чего-либо, 
как в случае тайпкласса `JsonWriter`:

```tut:book:invisible
trait Json
```

```tut:book
trait JsonWriter[-A] {
  def write(value: A): Json
}
```

Давайте разберём этот случай подробнее.
Помните: смысл вариантности состоит в возможности 
подставить одно значение вместо другого.
Рассмотрим сценарий, в котором у нас есть два значения: 
типа `Shape` и типа `Circle`; 
и два экземпляра `JsonWriter`: один для `Shape` и один для `Circle`:

```scala
val shape: Shape = ???
val circle: Circle = ???

val shapeWriter: JsonWriter[Shape] = ???
val circleWriter: JsonWriter[Circle] = ???
```

```tut:book:invisible
val shape: Shape = null
val circle: Circle = null

val shapeWriter: JsonWriter[Shape] = null
val circleWriter: JsonWriter[Circle] = null
```

```tut:book:silent
def format[A](value: A, writer: JsonWriter[A]): Json =
  writer.write(value)
```

Теперь задайте себе вопрос: 
«Какие комбинации значений и `JsonWriter` я могу передать в `format`?»
Мы можем комбинировать `circle` с любым `JsonWriter`, 
потому что все круги (`Circle`) являются фигурами (`Shape`).
И наоборот, мы не можем комбинировать `shape` с `circleWriter`, 
потому что не все фигуры являются кругами.

Для формального описания таких отношений мы и используем контравариантность.
`JsonWriter[Shape]` является подтипом `JsonWriter[Circle]`, 
потому что `Circle` является подтипом `Shape`.
Это означает, что мы можем использовать `shapeWriter` везде, 
где ожидается `JsonWriter[Circle] `.

**Инвариантность**

На самом деле, описать инвариантность проще всего.
Мы устанавливаем такое отношение всегда,
когда не указываем `+` или `-` в конструкторе типа:

```scala
trait F[A]
```

Это означает, что типы `F[A]` и `F[B]` 
никогда не являются подтипами друг друга, 
независимо от отношений между `A` и` B`.
Конструкторы типов в Scala имеют такую семантику по умолчанию.

Когда компилятор подбирает значения для неявных параметров, 
он ищет такое, которое соответствует нужному типу *или его подтипу*.
Таким образом, мы можем использовать аннотации вариантности для того, 
чтобы в некоторой степени влиять на выбор экземпляра тайпкласса.

Итак, есть два основных вопроса, возникающих в связи с вариантностью.
Представим, что у нас есть вот такой алгебраический тип данных:

```tut:book:silent
sealed trait A
final case object B extends A
final case object C extends A
```

Вопросы:

 1. Если существует экземпляр для супертипа, то будет ли он выбран?
    Например, можем ли мы определить экземпляр для `A` так, 
    чтобы он работал для значений типа `B` и `C`?

 2. Будет ли экземпляр для подтипа 
    выбран вместо экземпляра для супертипа?
    Например, если мы определим экземпляры как для `A`, так и для `B`, 
    и у нас будет значение типа `B`, 
    будет ли предпочтён экземпляр для `B`?

Оказывается, мы можем выбрать только одну из этих двух опций.
Три возможных выбора вариантности обеспечивают нам следующее поведение:

-----------------------------------------------------------------------------------------------
Вариантность тайпкласса                         Инвариантный   Ковариантный   Контравариантный
----------------------------------------------- -------------- -------------- -----------------
Будет ли использован экземпляр для супертипа?   Нет            Нет            Да 

Будет ли предпочтён более конкретный тип?       Нет            Да             Нет
-----------------------------------------------------------------------------------------------

Очевидно, что идеальной системы не существует.
В Cats отдаётся предпочтение инвариантным тайпклассам.
Такой выбор позволяет нам, при желании, 
указать более конкретные экземпляры для подтипов.
Из этого следует, что если у нас есть, к примеру, 
значение типа `Some[Int]`, 
то экземпляр для `Option` не подойдёт и не будет использован.
Мы можем решить эту проблему, 
явно указав тип (например, `Some(1): Option[Int]`) 
или с помощью *смарт-конструкторов* — 
методов вроде `Option.apply`, `Option.empty`, `some` и `none`, 
с которыми мы познакомились в разделе [@sec:type-classes:comparing-options].
