# Функторы

В этой главе мы изучим **функторы** —
абстракции, которые позволяют
выразить последовательное выполнение операций в некотором контексте,
таком как `List`, `Option` или каком-либо другом (существует множество вариантов).
Сами по себе функторы не особенно полезны,
но некоторые их разновидности, такие как
**монады** и **аппликативные функторы*,
являются одними из основных абстракций в Cats.

## Примеры функторов {#sec:functors:examples}

Говоря неформально, функтор — это нечто такое, что имеет метод `map`.
Вам наверняка известно множество типов, у которых есть такой метод:
`Option`, `List` и `Either` входят в их число.

Обычно люди знакомятся с `map`, когда требуется перебрать значения некоторого списка.
Но чтобы понять функторы по-настоящему,
нужно думать о методе `map` несколько иначе.
Его следует рассматривать не как последовательный перебор, 
а как преобразование сразу всех элементов.
От нас требуется предоставить некоторую функцию,
а `map` гарантирует, что она будет применена к каждому элементу.
Значения поменяются, но структура списка останется прежней:

```tut:book
List(1, 2, 3).map(n => n + 1)
```

Точно так же, когда мы используем `map` с `Option`,
мы трансформируем содержимое,
но при этом контекст `Some` или `None` остаётся неизменным.
Тот же принцип применяется к `Either`
с его контекстами `Left` и `Right`.
Схожесть в том, какой смысл вкладывается в понятие трансформации,
а также сходство сигнатур типов (рис. [@fig:functors:list-option-either-type-chart])
объединяет поведение `map` для разных типов данных.

![Диаграмма: отображение List, Option, и Either](src/pages/functors/list-option-either-map.pdf+svg){#fig:functors:list-option-either-type-chart}

Поскольку `map` оставляет структуру контекста неизменной, 
мы можем использовать цепочку его вызовов, чтобы упорядочить несколько вычислений 
для содержимого исходной структуры данных:

```tut:book
List(1, 2, 3).
  map(n => n + 1).
  map(n => n * 2).
  map(n => n + "!")
```

Мы должны думать о `map` не как об итерационном паттерне, 
а как о способе упорядочения вычислений 
для значений, игнорируя некоторые сложности, 
обусловленные соответствующим типом данных:

- `Option` — значение может присутствовать или отсутствовать;
- `Either` — тут может быть значение или ошибка;
- `List` — тут может быть ноль или более значений.

## Больше примеров функторов {#sec:functors:more-examples}

Метод `map` у `List`, `Option` и `Either`
использует энергичное вычисление. 
Однако, идея упорядоченых вычислений 
является более общей.
Рассмотрим поведение некоторых других функторов, 
которые применяют этот шаблон различными способами.

**Futures**

`Future` - это функтор, который 
упорядочивает асинхронные вычисления, ставя их в очередь 
и применяя их после того как выполнятся предыдущие вычисления.
Сигнатура его метода `map`,
показанного на рисунке [@fig:functors:future-type-chart], 
имеет ту же форму, что и сигнатуры выше. 
Тем не менее, поведение сильно отличается.

![Диаграмма: отображение Future](src/pages/functors/future-map.pdf+svg){#fig:functors:future-type-chart}

Когда мы работаем с `Future`, у нас нет никаких гарантий
относительно его внутреннего состояния. 
Вычисления могут
продолжаться, завершиться или быть отклонены.
Если `Future` завершается,
функция `map` может быть вызвана немедленно.
Если нет, то пул потоков ставит в очередь 
вызов функции и возвращается к нему позже. 
Мы не знаем, *когда* будут вызваны наши функции, 
но мы знаем, *в каком порядке* они будут вызваны. 
Таким образом, `Future` обеспечивает
то же самое поведение последовательности, 
что мы наблюдали в `List`, `Option` и `Either`:

```tut:book:silent
import scala.concurrent.{Future, Await}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._

val future: Future[String] =
  Future(123).
    map(n => n + 1).
    map(n => n * 2).
    map(n => n + "!")
```

```tut:book
Await.result(future, 1.second)
```

<div class="callout callout-info">
*Futures и ссылочная прозрачность*

Обратите внимание, что `Future` в Scala не является хорошим примером 
чисто функционального программирования, 
потому что он не обладает *ссылочной прозрачностью*.
`Future` всегда вычисляет и кеширует результат, 
и у нас нет возможности изменить это поведение.
Это означает, что мы можем получить непредсказуемые результаты,
если будем использовать `Future`, чтобы обернуть вычисления, приводящие к побочным эффектам.
Например:

```tut:book:silent
import scala.util.Random

val future1 = {
  // Инициализация Random заданным начальным значением:
  val r = new Random(0L)

  // nextInt имеет побочный эффект перехода к 
  // следующему случайному числу в последовательности:
  val x = Future(r.nextInt)

  for {
    a <- x
    b <- x
  } yield (a, b)
}

val future2 = {
  val r = new Random(0L)

  for {
    a <- Future(r.nextInt)
    b <- Future(r.nextInt)
  } yield (a, b)
}
```

```tut:book
val result1 = Await.result(future1, 1.second)
val result2 = Await.result(future2, 1.second)
```

В идеале мы бы хотели, чтобы `result1` и` result2` 
содержали одно и то же значение.
Тем не менее, вычисление для `future1` вызывает` nextInt` один раз,
а вычисление для `future2` вызывает его дважды.
Потому что `nextInt` возвращает разные результаты каждый раз,
мы получаем разные результаты в каждом случае.

Такое несоответствие затрудняет рассуждение о
программах, включающих `Futures` и побочные эффекты.
Существуют и другие проблемные аспекты поведения `Futures`, 
например, немедленный запуск вычисления,
без позволения пользователю решать, когда должна выполняться программа.
Для получения дополнительной информации 
посмотрите [этот превосходный ответ на Reddit][link-so-future] 
Роба Норриса.
</div>

Если `Future` не обладает ссылочной прозрачностью,
возможно, нам следует взглянуть на другой подобный тип данных.
Вам должны быть знакомы...

**Функции (?!)**

Оказывается, что функции одного аргумента также являются функторами.
Чтобы увидеть это, нам нужно немного подправить типы.
Функция `A => B` имеет два типа параметров: 
тип параметра `A` и тип результата `B`.
Чтобы привести их к правильной форме, мы можем
зафиксировать тип параметра и изменить тип результата:

 - начать с `X => A`;
 - подставить функцию `A => B`;
 - получить `X => B`.

Если представить тип `X => A` как `MyFunc[A]`,
можно увидеть тот же шаблон типов, который 
мы видели в других примерах этой главы.
Мы также видим это на рисунке [@fig:functors:function-type-chart]:

 - начать с `MyFunc[A]`;
 - подставить функцию `A => B`;
 - получить `MyFunc[B]`.

![Диаграмма: отображение Function1](src/pages/functors/function-map.pdf+svg){#fig:functors:function-type-chart}

Другими словами, `map` над `Function1` является композицией функций:

```tut:book:silent
import cats.instances.function._ // для Functor
import cats.syntax.functor._     // для map
```

```tut:book:silent
val func1: Int => Double =
  (x: Int) => x.toDouble

val func2: Double => Double =
  (y: Double) => y * 2
```

```tut:book
(func1 map func2)(1)     // композиция через map
(func1 andThen func2)(1) // композиция через andThen
func2(func1(1))          // композиция, написанная вручную
```

Как это связано с нашей общей схемой 
задания последовательности операций?
Если мы думаем об этом, 
композиция функций *является* последовательной.
Мы начинаем с функции, которая выполняет одну операцию,
и каждый раз, когда мы используем `map`, мы добавляем еще одну операцию в цепочку.
Вызов `map` на самом деле не *запускает* ни одну из операций,
но если мы можем передать аргумент конечной функции,
все операции выполняются последовательно.
Мы можем думать об этом как о лениво стоящих в очереди операциях,
похожих на `Future`:

```tut:book:silent
val func =
  ((x: Int) => x.toDouble).
    map(x => x + 1).
    map(x => x * 2).
    map(x => x + "!")
```

```tut:book
func(123)
```

<div class="callout callout-warning">
*Частичная унификация*

Чтобы вышеприведенные примеры работали,
нам нужно добавить следующую опцию компилятора в `build.sbt`:

```scala
scalacOptions += "-Ypartial-unification"
```

в противном случае мы получим ошибку компилятора:

```scala
func1.map(func2)
// <console>: error: value map is not a member of Int => Double
//        func1.map(func2)
                ^
```

Мы рассмотрим подробнее, почему это происходит
в разделе [@sec:functors:partial-unification].
</div>

## Определение функтора

Каждый пример, который мы рассмотрели ранее, является функтором: 
классом, который инкапсулирует вычисления последовательности.
Формально функтор - это тип `F [A]`
с операцией `map` с типом `(A => B) => F[B]`.
Общая диаграмма типов показана на 
рисунке [@fig:functors:functor-type-chart].

![Диаграмма: обобщенное отображение функторов](src/pages/functors/generic-map.pdf+svg){#fig:functors:functor-type-chart}

Cats определяет `Functor` как тайпкласс,
[`cats.Functor`][cats.Functor],
поэтому метод выглядит немного иначе.
Он принимает начальный `F[A]` в качестве параметра
вместе с функцией преобразования.
Вот упрощенная версия определения:

```scala
package cats
```

```tut:book:silent
import scala.language.higherKinds

trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```

Если вы не видели синтаксис, подобный `F[_]`, 
пришло время для небольшого отступления, чтобы обсудить 
*конструкторы типов* и *типы высшего порядка*.
Мы также объясним, что импортирует `scala.language`.

<div class="callout callout-warning">
*Законы функторов*

Функторы гарантируют одинаковую семантику,
независимо от того, последовательно мы выполняем множество небольших операций 
или объединяем их в большую функцию перед `mapping`.
Чтобы убедиться в этом, должны соблюдаться следующие законы:

*Тождественность*: вызвать`map` с тождественным отображением
это то же самое, что ничего не делать

```scala
fa.map(a => a) == fa
```

*Композиция*: вызов `map` от двух функций `f` и `g` 
аналогичен вызову `map` от `f` и затем `map` от `g`:

```scala
fa.map(g(f(_))) == fa.map(f).map(g)
```
</div>

## Отступление: Понятия «род» и «конструктор типов»

Виды как типы для типов.
Они описывают количество "дыр" в типе.
Мы различаем обычные типы, у которых нет отверстий, 
и "конструкторы типов", у которых есть
отверстия, которые мы можем заполнить для создания типов.

Например, `List` - это конструктор типов с одним отверстием.
Мы заполним эту дыру, указав параметр для создания
обычного типа, такого как `List[Int]` или `List [A]`.
Хитрость заключается в том, чтобы не путать конструкторы типов с обобщёнными типами.
`List` - это конструктор типа, `List [A] `- это тип:

```scala
List    // конструктор типов, принимающий один параметр
List[A] // тип, полученный с использованием параметра
```

Здесь есть близкая аналогия с функциями и значениями.
Функции являются "конструкторами значений" — они
генерируют значения, когда мы подставляем параметры:

```scala
math.abs    // функция, принимающая один параметр
math.abs(x) // значение, полученное с использованием параметра
```

В Scala мы объявляем конструкторы типов, используя подчеркивания.
Однако после того, как мы их объявили, 
мы ссылаемся на них, как на простые идентификаторы:

```scala
// Объявление F через подчеркивание:
def myMethod[F[_]] = {

  // Ссылка на F без подчеркивания:
  val functor = Functor.apply[F]

  // ...
}
```

Это аналогично указанию параметров функции 
в ее определении и пропуску их при обращении к ней:

```scala
// Объявление f c параметрами:
val f = (x: Int) => x * 2

// Ссылка на f без параметров:
val f2 = f andThen f
```

Вооружившись знанием о конструкторах типов, 
мы можем видеть, что в Cats определение `Functor`
позволяет нам создавать экземпляры для любого конструктора типа от одного параметра,
такого как `List`, `Option`, `Future`, или псевдоним типа, такой как `MyFunc`.

<div class="callout callout-info">
*Импорт расширенной функциональности языка*

Типы высшего порядка считаются расширенной функциональностью языка в Scala.
Всякий раз, когда мы объявляем конструктор типа с синтаксисом `A[_]`,
нам нужно "включать" функциональность типов высшего порядка
для подавления предупреждений от компилятора. 
Мы можем сделать это с помощью «языкового импорта», как указано выше:

```scala
import scala.language.higherKinds
```

или добавив следующее в `scalacOptions` в `build.sbt`:

```scala
scalacOptions += "-language:higherKinds"
```

Мы будем использовать импорт в этой книге,
чтобы быть максимально понятными.
На практике, однако, мы находим флаг `scalacOptions`
более простым и менее многословным.
</div>
