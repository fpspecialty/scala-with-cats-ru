# Функторы

В этой главе мы изучим **функторы** —
абстракции, которые позволяют
выразить последовательное выполнение операций в некотором контексте,
таком как `List`, `Option` или каком-либо другом (существует множество вариантов).
Сами по себе функторы не особенно полезны,
но некоторые их разновидности, такие как
**монады** и **аппликативные функторы**,
являются одними из основных абстракций в Cats.

## Примеры функторов {#sec:functors:examples}

Говоря неформально, функтор — это нечто такое, что имеет метод `map`.
Вам наверняка известно множество типов, у которых есть такой метод:
`Option`, `List` и `Either` входят в их число.

Обычно люди знакомятся с `map`, когда требуется перебрать значения некоторого списка.
Но чтобы понять функторы по-настоящему,
нужно думать о методе `map` несколько иначе.
Его следует рассматривать не как последовательный перебор, 
а как преобразование сразу всех элементов.
От нас требуется предоставить некоторую функцию,
а `map` гарантирует, что она будет применена к каждому элементу.
Значения поменяются, но структура списка останется прежней:

```tut:book
List(1, 2, 3).map(n => n + 1)
```

Точно так же, когда мы используем `map` с `Option`,
мы трансформируем содержимое,
но при этом контекст `Some` или `None` остаётся неизменным.
Тот же принцип применяется к `Either`
с его контекстами `Left` и `Right`.
Схожесть в том, какой смысл вкладывается в понятие трансформации,
а также сходство сигнатур типов (рис. [@fig:functors:list-option-either-type-chart])
объединяют поведение `map` для разных типов данных.

![Диаграмма: отображение List, Option, и Either](src/pages/functors/list-option-either-map.pdf+svg){#fig:functors:list-option-either-type-chart}

Поскольку `map` оставляет структуру контекста неизменной, 
мы можем использовать цепочку его вызовов, чтобы упорядочить несколько вычислений 
для содержимого исходной структуры данных:

```tut:book
List(1, 2, 3).
  map(n => n + 1).
  map(n => n * 2).
  map(n => n + "!")
```

Мы должны думать о `map` не как о приёме итерирования, 
а как о способе последовательно выполнять вычисления над значениями,
не беспокоясь о сложностях, 
обусловленных соответствующим типом данных:

- `Option` — значение может присутствовать или отсутствовать;
- `Either` — тут может быть значение или ошибка;
- `List` — тут может быть ноль или более значений.

## Другие примеры функторов {#sec:functors:more-examples}

Метод `map` у `List`, `Option` и `Either`
использует энергичное вычисление. 
Однако, идея упорядоченых вычислений 
является более общей.
Рассмотрим поведение некоторых других функторов, 
которые реализуют этот паттерн различными способами.

**Futures**

`Future` - это функтор, который 
упорядочивает асинхронные вычисления, ставя их в очередь 
и применяя их после того как выполнятся предыдущие вычисления.
Сигнатура его метода `map`,
показанная на рисунке [@fig:functors:future-type-chart], 
выглядит подобно другим сигнатурам `map`. 
Тем не менее, поведение сильно отличается.

![Диаграмма: отображение Future](src/pages/functors/future-map.pdf+svg){#fig:functors:future-type-chart}

Когда мы работаем с `Future`, у нас нет никаких гарантий
относительно его внутреннего состояния. 
Вычисления могут
находиться в завершённом или незавершённом состояниях, а также могут быть прерваны.
Если `Future` находится в завершённом состоянии,
функция `map` может быть вызвана немедленно.
Если нет, то пул потоков ставит в очередь 
вызов функции и возвращается к нему позже. 
Мы не знаем, *когда* будут вызваны наши функции, 
но мы знаем, *в каком порядке* они будут вызваны. 
Таким образом, `Future` обеспечивает
такое же «последовательное» поведение, 
что и `List`, `Option` и `Either`:

```tut:book:silent
import scala.concurrent.{Future, Await}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._

val future: Future[String] =
  Future(123).
    map(n => n + 1).
    map(n => n * 2).
    map(n => n + "!")
```

```tut:book
Await.result(future, 1.second)
```

<div class="callout callout-info">
*Futures и ссылочная прозрачность*

Стоит отметить, что `Future` в Scala — не лучший пример
чисто функционального программирования, 
потому что он не обладает *ссылочной прозрачностью*.
`Future` всегда вычисляет и кеширует результат, 
и у нас нет возможности изменить это поведение.
Это означает, что мы можем получить непредсказуемые результаты,
если будем использовать `Future`, чтобы обернуть вычисления, приводящие к побочным эффектам.
Например:

```tut:book:silent
import scala.util.Random

val future1 = {
  // Инициализируем Random заданным начальным значением:
  val r = new Random(0L)

  // nextInt имеет побочный эффект перехода к 
  // следующему случайному числу в последовательности:
  val x = Future(r.nextInt)

  for {
    a <- x
    b <- x
  } yield (a, b)
}

val future2 = {
  val r = new Random(0L)

  for {
    a <- Future(r.nextInt)
    b <- Future(r.nextInt)
  } yield (a, b)
}
```

```tut:book
val result1 = Await.result(future1, 1.second)
val result2 = Await.result(future2, 1.second)
```

В идеале мы бы хотели, чтобы `result1` и `result2` 
содержали одно и то же значение.
Тем не менее, вычисление для `future1` вызывает `nextInt` один раз,
а вычисление для `future2` вызывает его дважды.
Мы рассчитываем, что `nextInt` с каждым вызовом будет возвращать нам новое значение,
но в случае `future1` этого не произойдёт, и результаты `future1` и `future2` будут различаться.

Такое несоответствие затрудняет рассуждение о
программах, использующих `Futures` и побочные эффекты.
У поведения  `Future` есть и другие проблемные аспекты —
например, немедленный запуск вычисления,
не позволяющий пользователю самому выбрать,
в какой именно момент программа должна начать выполняться.
Для получения дополнительной информации 
посмотрите [этот превосходный ответ на Reddit][link-so-future] 
Роба Норриса.
</div>

Если `Future` не обладает ссылочной прозрачностью,
возможно, нам следует взглянуть на другой подобный тип данных.
Вы наверняка с ним знакомы...

**Функции (?!)**

Оказывается, что функции одного аргумента также являются функторами.
Чтобы увидеть это, нам нужно немного по-другому взглянуть на типы.
Функция `A => B` имеет два типовых параметра: 
тип аргумента `A` и тип возвращаемого значения `B`.
Чтобы привести их к удобной нам форме, мы можем
зафиксировать тип аргумента, а тип возвращаемого значения оставить переменным:

 - имеем `X => A`;
 - подставляем функцию `A => B`;
 - получаем `X => B`.

Если переименовать тип `X => A` в `MyFunc[A]`,
то будет заметно сходство типов
с другими примерами из этой главы.
Мы также видим это на рисунке [@fig:functors:function-type-chart]:

 - имеем `MyFunc[A]`;
 - подставляем функцию `A => B`;
 - получаем `MyFunc[B]`.

![Диаграмма: отображение Function1](src/pages/functors/function-map.pdf+svg){#fig:functors:function-type-chart}

Другими словами, отображение `Function1` является композицией функций:

```tut:book:silent
import cats.instances.function._ // для Functor
import cats.syntax.functor._     // для map
```

```tut:book:silent
val func1: Int => Double =
  (x: Int) => x.toDouble

val func2: Double => Double =
  (y: Double) => y * 2
```

```tut:book
(func1 map func2)(1)     // композиция через map
(func1 andThen func2)(1) // композиция через andThen
func2(func1(1))          // композиция, выполненная вручную
```

Как это связано с поведением функторов
(последовательным выполнением операций)?
Если задуматься, 
композиция функций и *является* этим последовательным выполнением.
У нас есть функция, которая выполняет одну операцию,
и с каждым применением `map` мы добавляем в последовательность ещё одну операцию.
Вызов `map` на самом деле *не запускает* ни одну из операций,
но если итоговой функции передать её аргумент,
то все операции выполняются последовательно.
Мы можем думать об этом как о лениво стоящих в очереди операциях,
подобно `Future`:

```tut:book:silent
val func =
  ((x: Int) => x.toDouble).
    map(x => x + 1).
    map(x => x * 2).
    map(x => x + "!")
```

```tut:book
func(123)
```

<div class="callout callout-warning">
*Частичная унификация*

Чтобы вышеприведенные примеры работали,
нужно добавить следующую опцию компилятора в `build.sbt`:

```scala
scalacOptions += "-Ypartial-unification"
```

в противном случае мы получим ошибку компиляции:

```scala
func1.map(func2)
// <console>: error: value map is not a member of Int => Double
//        func1.map(func2)
                ^
```

Рассмотрим подробнее, почему это происходит
в разделе [@sec:functors:partial-unification].
</div>

## Определение функтора

Каждый рассмотренный нами пример является функтором —
тайпклассом, который выражает последовательные вычисления.
Формально, функтор — это тип `F[A]`
с операцией `map` типа `(A => B) => F[B]`.
Общая диаграмма типов показана на 
рисунке [@fig:functors:functor-type-chart].

![Диаграмма: обобщенное отображение функторов](src/pages/functors/generic-map.pdf+svg){#fig:functors:functor-type-chart}

Cats определяет `Functor` как тайпкласс,
[`cats.Functor`][cats.Functor],
поэтому метод выглядит немного иначе.
Он принимает начальный `F[A]` в качестве параметра
вместе с функцией преобразования.
Вот упрощенное определение:

```scala
package cats
```

```tut:book:silent
import scala.language.higherKinds

trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```

Если ранее вам не встречался синтаксис вроде `F[_]`, 
то пришло время для небольшого отступления, чтобы обсудить 
*конструкторы типов* и *типы высшего порядка*.
Также мы объясним, что именно импортирует `scala.language`.

<div class="callout callout-warning">
*Законы функторов*

Функторы гарантируют одинаковую семантику
как для нескольких последовательных применений `map` с некоторыми операциями,
так и для применения `map` с композицией этих операций
(соединённых в одну большую функцию до применения `map`).
А чтобы мы могли быть уверены в этом, экземпляром должны соблюдаться следующие законы:

*Тождественность*: применить `map` с тождественным отображением (функцией identity) —
это то же самое, что не делать ничего:

```scala
fa.map(a => a) == fa
```

*Композиция*: вызов `map` от двух функций `f` и `g` 
аналогичен вызову `map` от `f` и затем `map` от `g`:

```scala
fa.map(g(f(_))) == fa.map(f).map(g)
```
</div>

## Отступление: Понятия «род» и «конструктор типов»

Род (kind) — это как тип для типов.
Род описывает количество недостающих типовых параметров (или, как часто говорят, количество «дырок»).
Мы различаем обычные типы, у которых нет «дырок», 
и конструкторы типов, у которых «дырки» есть, и чтобы создать некоторый тип, нужно их заполнить.

Например, `List` — это конструктор типа с одной «дыркой».
Мы можем заполнить эту «дырку», передав ему типовый параметр,
и таким образом создадим конкретный тип, такой как `List[Int]` или `List[A]`.
Важно не путать конструкторы типов с обобщёнными типами.
`List` — это конструктор типа, `List[A] `— это тип:

```scala
List    // конструктор типов, принимающий один параметр
List[A] // тип, полученный с использованием параметра
```

Здесь есть близкая аналогия с функциями и значениями.
Функции являются «конструкторами значений» — они
производят значения, когда мы передаём им параметры:

```scala
math.abs    // функция, принимающая один параметр
math.abs(x) // значение, полученное с использованием параметра
```

В Scala мы объявляем конструкторы типов, используя знак подчеркивания.
Однако, после того, как мы их объявили, 
мы обращаемся к ним так же, как и ко всем остальным идентификаторам:

```scala
// Объявление F через подчеркивание:
def myMethod[F[_]] = {

  // Ссылка на F без подчеркивания:
  val functor = Functor.apply[F]

  // ...
}
```

Это аналогично указанию параметров функции 
в ее определении и пропуску их при обращении к ней:

```scala
// Объявление f c параметрами:
val f = (x: Int) => x * 2

// Ссылка на f без параметров:
val f2 = f andThen f
```

Вооружившись знанием о конструкторах типов, можно увидеть, 
что в Cats определение `Functor` позволяет создавать экземпляры
для любого однопараметрического конструктора типа
(т.е. такого, который может принять один типовый параметр).
К ним относятся `List`, `Option`, `Future`, а также псевдонимы вроде `MyFunc`.

<div class="callout callout-info">
*Импорт расширенной функциональности языка*

Типы высшего порядка считаются расширенной функциональностью языка в Scala.
Всякий раз, когда мы объявляем конструктор типа с синтаксисом `A[_]`,
нам нужно «включать» поддержку типов высшего порядка
для подавления предупреждений от компилятора. 
Мы можем сделать это с помощью «языкового импорта», как указано выше:

```scala
import scala.language.higherKinds
```

или добавив следующее в `scalacOptions` в `build.sbt`:

```scala
scalacOptions += "-language:higherKinds"
```

В этой книге мы будем использовать импорт,
чтобы поведение примеров было определено как можно более явно.
На практике, однако, мы находим флаг `scalacOptions`
более простым и кратким.
</div>
